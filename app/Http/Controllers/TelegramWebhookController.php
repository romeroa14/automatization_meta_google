<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Http;
use App\Models\User;
use App\Models\FacebookAccount;
use App\Models\AdvertisingPlan;
use App\Services\CampaignCreationFlowService;
use App\Services\ConversationStateService;

class TelegramWebhookController extends Controller
{
    public function handle(Request $request)
    {
        try {
            Log::info('üì± Webhook de Telegram recibido', [
                'ip' => $request->ip(),
                'user_agent' => $request->userAgent(),
                'timestamp' => now(),
                'data' => $request->all()
            ]);

            $update = $request->all();
            
            if (isset($update['message'])) {
                return $this->handleMessage($update['message']);
            }
            
            if (isset($update['callback_query'])) {
                return $this->handleCallbackQuery($update['callback_query']);
            }

            Log::warning('‚ö†Ô∏è Tipo de update no reconocido', ['update' => $update]);
            return response()->json(['ok' => true]);

        } catch (\Exception $e) {
            Log::error('‚ùå Error en webhook de Telegram', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'request' => $request->all()
            ]);
            
            return response()->json(['ok' => false, 'error' => $e->getMessage()], 500);
        }
    }

    private function handleMessage(array $message)
    {
        $chatId = $message['chat']['id'];
        $text = $message['text'] ?? '';
        $userId = $message['from']['id'] ?? null;
        $username = $message['from']['username'] ?? 'Usuario';

        Log::info('üí¨ Mensaje recibido', [
            'chat_id' => $chatId,
            'user_id' => $userId,
            'username' => $username,
            'text' => $text
        ]);

        // Comandos disponibles
        $commands = [
            '/start' => 'startCommand',
            '/help' => 'helpCommand',
            '/crear_campana' => 'createCampaignCommand',
            '/otro_ad' => 'createAnotherAdCommand',
            '/mis_cuentas' => 'myAccountsCommand',
            '/planes' => 'plansCommand',
            '/estado' => 'statusCommand',
            '/cancelar' => 'cancelCommand',
            '/progreso' => 'progressCommand'
        ];

        $command = explode(' ', $text)[0];
        
        if (isset($commands[$command])) {
            return $this->{$commands[$command]}($chatId, $message);
        }

        // Si no es un comando, verificar si hay una conversaci√≥n activa
        $conversationState = new ConversationStateService();
        $isActive = $conversationState->isConversationActive($chatId);
        
        Log::info('üîç Verificando conversaci√≥n activa', [
            'chat_id' => $chatId,
            'text' => $text,
            'is_active' => $isActive
        ]);
        
        if ($isActive) {
            return $this->handleConversationStep($chatId, $text);
        }

        // Si no hay conversaci√≥n activa, mostrar ayuda
        return $this->sendMessage($chatId, $this->getHelpMessage());
    }

    private function startCommand($chatId, $message)
    {
        $welcomeMessage = "ü§ñ *Bienvenido al Bot de AdM√©tricas*\n\n";
        $welcomeMessage .= "Soy tu asistente para crear campa√±as publicitarias de Meta de forma r√°pida y eficiente.\n\n";
        $welcomeMessage .= "üìã *Comandos disponibles:*\n";
        $welcomeMessage .= "/crear_campana - Crear una nueva campa√±a\n";
        $welcomeMessage .= "/otro_ad - Crear otro anuncio (mantiene cuenta publicitaria)\n";
        $welcomeMessage .= "/mis_cuentas - Ver cuentas de Facebook disponibles\n";
        $welcomeMessage .= "/planes - Ver planes publicitarios disponibles\n";
        $welcomeMessage .= "/estado - Ver estado del sistema\n";
        $welcomeMessage .= "/help - Mostrar esta ayuda\n\n";
        $welcomeMessage .= "üöÄ ¬°Empecemos a crear campa√±as!";

        return $this->sendMessage($chatId, $welcomeMessage);
    }

    private function helpCommand($chatId, $message)
    {
        return $this->sendMessage($chatId, $this->getHelpMessage());
    }

    private function createCampaignCommand($chatId, $message)
    {
        $conversationState = new ConversationStateService();
        $flowService = new CampaignCreationFlowService();
        
        // Iniciar nueva conversaci√≥n
        $conversationState->clearConversationState($chatId);
        $conversationState->updateConversationStep($chatId, 'start');
        
        $startMessage = $flowService->getStepMessage('start');
        return $this->sendMessage($chatId, $startMessage);
    }

    private function createAnotherAdCommand($chatId, $message)
    {
        $conversationState = new ConversationStateService();
        $flowService = new CampaignCreationFlowService();
        
        // Verificar si hay una conversaci√≥n previa con cuenta publicitaria
        $previousState = $conversationState->getConversationState($chatId);
        
        if (!$previousState || !isset($previousState['data']['ad_account'])) {
            return $this->sendMessage($chatId, 
                "‚ùå *No hay cuenta publicitaria seleccionada.*\n\n" .
                "üí° *Opciones:*\n" .
                "‚Ä¢ Usa /crear_campana para flujo completo\n" .
                "‚Ä¢ O selecciona una cuenta publicitaria primero"
            );
        }
        
        // Iniciar nueva conversaci√≥n pero mantener cuenta publicitaria
        $conversationState->clearConversationState($chatId);
        $conversationState->updateConversationStep($chatId, 'fanpage');
        
        // Preservar la cuenta publicitaria seleccionada
        $conversationState->updateConversationData($chatId, 'ad_account', $previousState['data']['ad_account']);
        
        // Obtener nombre de la cuenta publicitaria de forma segura
        $adAccountName = $previousState['data']['ad_account_name'] ?? 'Cuenta seleccionada';
        $conversationState->updateConversationData($chatId, 'ad_account_name', $adAccountName);
        
        $message = "üîÑ *Crear Otro Anuncio*\n\n";
        $message .= "‚úÖ *Cuenta publicitaria:* " . $adAccountName . "\n\n";
        $message .= $flowService->getStepMessage('fanpage');
        
        return $this->sendMessage($chatId, $message);
    }

    private function myAccountsCommand($chatId, $message)
    {
        try {
            $accounts = FacebookAccount::where('is_active', true)->get();
            
            if ($accounts->isEmpty()) {
                return $this->sendMessage($chatId, "‚ùå No hay cuentas de Facebook activas disponibles.");
            }

            $message = "üì± *Cuentas de Facebook Disponibles:*\n\n";
            foreach ($accounts as $account) {
                $message .= "üîπ *{$account->account_name}*\n";
                $message .= "   App ID: `{$account->app_id}`\n";
                $message .= "   Estado: " . ($account->is_active ? "‚úÖ Activa" : "‚ùå Inactiva") . "\n\n";
            }

            return $this->sendMessage($chatId, $message);

        } catch (\Exception $e) {
            Log::error('Error obteniendo cuentas de Facebook', ['error' => $e->getMessage()]);
            return $this->sendMessage($chatId, "‚ùå Error al obtener las cuentas de Facebook.");
        }
    }

    private function plansCommand($chatId, $message)
    {
        try {
            $plans = AdvertisingPlan::where('is_active', true)->get();
            
            if ($plans->isEmpty()) {
                return $this->sendMessage($chatId, "‚ùå No hay planes publicitarios disponibles.");
            }

            $message = "üìä *Planes Publicitarios Disponibles:*\n\n";
            foreach ($plans as $plan) {
                $message .= "üîπ *{$plan->name}*\n";
                $message .= "   Presupuesto diario: \${$plan->daily_budget}\n";
                $message .= "   Duraci√≥n: {$plan->duration_days} d√≠as\n";
                $message .= "   Precio: \${$plan->client_price}\n\n";
            }

            return $this->sendMessage($chatId, $message);

        } catch (\Exception $e) {
            Log::error('Error obteniendo planes publicitarios', ['error' => $e->getMessage()]);
            return $this->sendMessage($chatId, "‚ùå Error al obtener los planes publicitarios.");
        }
    }

    private function statusCommand($chatId, $message)
    {
        try {
            $userCount = User::count();
            $activeAccounts = FacebookAccount::where('is_active', true)->count();
            $activePlans = AdvertisingPlan::where('is_active', true)->count();

            $statusMessage = "üìä *Estado del Sistema*\n\n";
            $statusMessage .= "üë• Usuarios: {$userCount}\n";
            $statusMessage .= "üì± Cuentas FB activas: {$activeAccounts}\n";
            $statusMessage .= "üìã Planes activos: {$activePlans}\n";
            $statusMessage .= "üïê √öltima actualizaci√≥n: " . now()->format('d/m/Y H:i:s') . "\n\n";
            $statusMessage .= "‚úÖ Sistema funcionando correctamente";

            return $this->sendMessage($chatId, $statusMessage);

        } catch (\Exception $e) {
            Log::error('Error obteniendo estado del sistema', ['error' => $e->getMessage()]);
            return $this->sendMessage($chatId, "‚ùå Error al obtener el estado del sistema.");
        }
    }

    private function handleCallbackQuery(array $callbackQuery)
    {
        $chatId = $callbackQuery['message']['chat']['id'];
        $data = $callbackQuery['data'];
        $queryId = $callbackQuery['id'];

        Log::info('üîò Callback query recibido', [
            'chat_id' => $chatId,
            'data' => $data,
            'query_id' => $queryId
        ]);

        // Aqu√≠ manejaremos las respuestas a botones inline
        // Por ahora, solo confirmamos la recepci√≥n
        $this->answerCallbackQuery($queryId, "Comando procesado: {$data}");
        
        return response()->json(['ok' => true]);
    }

    private function mapTemplateData(array $templateData, array $existingData): array
    {
        $mappedData = $existingData; // Mantener datos existentes (cuenta, fanpage)
        
        // Mapear campos de la plantilla
        if (isset($templateData['campaign_name'])) {
            $mappedData['campaign_name'] = $templateData['campaign_name'];
        }
        
        if (isset($templateData['campaign_objective'])) {
            $mappedData['campaign_objective'] = $templateData['campaign_objective'];
        }
        
        if (isset($templateData['budget_type'])) {
            $mappedData['budget_type'] = $templateData['budget_type'];
        }
        
        if (isset($templateData['daily_budget'])) {
            $mappedData['daily_budget'] = $templateData['daily_budget'];
        }
        
        if (isset($templateData['start_date']) && isset($templateData['end_date'])) {
            $mappedData['dates'] = [
                'start' => $templateData['start_date'],
                'end' => $templateData['end_date']
            ];
        }
        
        if (isset($templateData['geolocation'])) {
            $mappedData['geolocation'] = $templateData['geolocation'];
        }
        
        if (isset($templateData['age_min']) && isset($templateData['age_max'])) {
            $mappedData['audience_details'] = $templateData['age_min'] . '-' . $templateData['age_max'] . ' ' . ($templateData['gender'] ?? 'ambos');
        }
        
        if (isset($templateData['ad_placement'])) {
            $mappedData['ad_placement'] = $templateData['ad_placement'];
        }
        
        if (isset($templateData['ad_name'])) {
            $mappedData['ad_name'] = $templateData['ad_name'];
        }
        
        if (isset($templateData['creative_type'])) {
            $mappedData['creative_type'] = $templateData['creative_type'];
        }
        
        if (isset($templateData['ad_copy'])) {
            $mappedData['ad_copy'] = $templateData['ad_copy'];
        }
        
        return $mappedData;
    }

    private function sendMessage($chatId, $text, $parseMode = 'Markdown')
    {
        $botToken = config('services.telegram.bot_token');
        
        if (!$botToken) {
            Log::error('‚ùå Bot token de Telegram no configurado');
            return response()->json(['ok' => false, 'error' => 'Bot token not configured']);
        }

        try {
            // Limpiar el texto para evitar problemas con Markdown
            $cleanText = $this->cleanMarkdownText($text);
            
            $response = Http::post("https://api.telegram.org/bot{$botToken}/sendMessage", [
                'chat_id' => $chatId,
                'text' => $cleanText,
                'parse_mode' => $parseMode,
                'disable_web_page_preview' => true
            ]);

            if ($response->successful()) {
                $data = $response->json();
                if ($data['ok']) {
                    Log::info('‚úÖ Mensaje enviado exitosamente', [
                        'chat_id' => $chatId,
                        'message_id' => $data['result']['message_id']
                    ]);
                    return response()->json(['ok' => true]);
                } else {
                    Log::error('‚ùå Error enviando mensaje', [
                        'error' => $data['description'],
                        'response' => $data
                    ]);
                    return response()->json(['ok' => false, 'error' => $data['description']]);
                }
            } else {
                Log::error('‚ùå Error HTTP enviando mensaje', [
                    'status' => $response->status(),
                    'body' => $response->body()
                ]);
                return response()->json(['ok' => false, 'error' => 'HTTP error']);
            }

        } catch (\Exception $e) {
            Log::error('‚ùå Excepci√≥n enviando mensaje', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return response()->json(['ok' => false, 'error' => $e->getMessage()]);
        }
    }
    
    private function cleanMarkdownText($text)
    {
        // Escapar caracteres especiales de Markdown que pueden causar problemas
        $text = str_replace(['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!'], 
                           ['\_', '\*', '\[', '\]', '\(', '\)', '\~', '\`', '\>', '\#', '\+', '\-', '\=', '\|', '\{', '\}', '\.', '\!'], 
                           $text);
        
        // Limitar la longitud del mensaje (m√°ximo 4096 caracteres)
        if (strlen($text) > 4096) {
            $text = substr($text, 0, 4093) . '...';
        }
        
        return $text;
    }

    private function answerCallbackQuery($queryId, $text = null)
    {
        $botToken = config('services.telegram.bot_token');
        
        if (!$botToken) {
            return;
        }

        try {
            Http::post("https://api.telegram.org/bot{$botToken}/answerCallbackQuery", [
                'callback_query_id' => $queryId,
                'text' => $text,
                'show_alert' => false
            ]);
        } catch (\Exception $e) {
            Log::error('Error respondiendo callback query', ['error' => $e->getMessage()]);
        }
    }

    private function processCampaignData($chatId, $text)
    {
        // M√©todo temporalmente deshabilitado para evitar errores de base de datos
        return $this->sendMessage($chatId, "üîß *Funcionalidad en desarrollo*\n\nPor ahora, usa /crear_campana para ver las instrucciones.");
    }

    private function createCampaign($chatId, $campaignData)
    {
        try {
            Log::info('üöÄ Creando campa√±a', [
                'chat_id' => $chatId,
                'campaign_data' => $campaignData
            ]);

            // Aqu√≠ implementaremos la creaci√≥n real de la campa√±a con Meta API
            // Por ahora, solo confirmamos que los datos est√°n correctos
            
            $successMessage = "‚úÖ *Campa√±a procesada exitosamente!*\n\n";
            $successMessage .= "üìä *Datos confirmados:*\n";
            $successMessage .= "‚Ä¢ Nombre: " . $campaignData['name'] . "\n";
            $successMessage .= "‚Ä¢ Objetivo: " . $campaignData['objective'] . "\n";
            $successMessage .= "‚Ä¢ Presupuesto: $" . $campaignData['daily_budget'] . "/d√≠a\n";
            $successMessage .= "‚Ä¢ Duraci√≥n: " . $campaignData['duration_days'] . " d√≠as\n";
            $successMessage .= "‚Ä¢ Cuenta: " . $campaignData['facebook_account'] . "\n\n";
            
            if ($campaignData['start_date'] && $campaignData['end_date']) {
                $successMessage .= "‚Ä¢ Fechas: " . $campaignData['start_date'] . " - " . $campaignData['end_date'] . "\n\n";
            }
            
            $successMessage .= "üîÑ *Pr√≥ximos pasos:*\n";
            $successMessage .= "1. Validar cuenta de Facebook\n";
            $successMessage .= "2. Crear campa√±a en Meta\n";
            $successMessage .= "3. Configurar audiencia\n";
            $successMessage .= "4. Crear anuncios\n\n";
            $successMessage .= "‚è≥ *Procesando...*";

            return $this->sendMessage($chatId, $successMessage);

        } catch (\Exception $e) {
            Log::error('‚ùå Error creando campa√±a', [
                'error' => $e->getMessage(),
                'chat_id' => $chatId,
                'campaign_data' => $campaignData
            ]);

            $errorMessage = "‚ùå *Error creando la campa√±a:*\n\n";
            $errorMessage .= "Error: " . $e->getMessage() . "\n\n";
            $errorMessage .= "üí° *Contacta al administrador para m√°s ayuda.*";
            
            return $this->sendMessage($chatId, $errorMessage);
        }
    }

    private function handleConversationStep($chatId, $text)
    {
        try {
            $conversationState = new ConversationStateService();
            $flowService = new CampaignCreationFlowService();
            
            $state = $conversationState->getConversationState($chatId);
            $currentStep = $state['step'];
            
            Log::info('üîÑ Procesando paso de conversaci√≥n', [
                'chat_id' => $chatId,
                'current_step' => $currentStep,
                'input' => $text
            ]);
            
            // Manejar comandos especiales
            if (strtoupper($text) === 'CANCELAR') {
                $conversationState->clearConversationState($chatId);
                return $this->sendMessage($chatId, "‚ùå *Conversaci√≥n cancelada.*\n\nUsa /crear_campana para comenzar de nuevo.");
            }
            
            // Manejar paginaci√≥n de fanpages
            if ($currentStep === 'fanpage') {
                if (strtoupper($text) === 'SIGUIENTE' || strtoupper($text) === 'M√ÅS') {
                    $currentPage = $state['data']['fanpage_page'] ?? 1;
                    $nextPage = $currentPage + 1;
                    
                    // Guardar p√°gina actual
                    $conversationState->updateConversationData($chatId, 'fanpage_page', $nextPage);
                    
                    // Mostrar siguiente p√°gina
                    $message = $flowService->getFanpageMessagePaginated($nextPage);
                    return $this->sendMessage($chatId, $message);
                }
                
                if (strtoupper($text) === 'ANTERIOR') {
                    $currentPage = $state['data']['fanpage_page'] ?? 1;
                    $prevPage = max(1, $currentPage - 1);
                    
                    // Guardar p√°gina actual
                    $conversationState->updateConversationData($chatId, 'fanpage_page', $prevPage);
                    
                    // Mostrar p√°gina anterior
                    $message = $flowService->getFanpageMessagePaginated($prevPage);
                    return $this->sendMessage($chatId, $message);
                }
            }
            
            // Validar y procesar datos del paso actual
            $validation = $flowService->validateStepData($currentStep, $text);
            
            Log::info('üîç Validaci√≥n de paso', [
                'chat_id' => $chatId,
                'current_step' => $currentStep,
                'input' => $text,
                'validation_result' => $validation
            ]);
            
            if (!$validation['valid']) {
                $errorMessage = "‚ùå *Error de validaci√≥n:*\n\n";
                $errorMessage .= $validation['error'] . "\n\n";
                $errorMessage .= "üí° *Intenta nuevamente o escribe 'CANCELAR' para salir.*";
                return $this->sendMessage($chatId, $errorMessage);
            }
            
            // Guardar datos del paso actual
            $conversationState->updateConversationData($chatId, $currentStep, $validation['data']);
            
            // Manejar selecci√≥n de fanpage - obtener informaci√≥n de Instagram
            if ($currentStep === 'fanpage') {
                $selectedPageId = $validation['data'];
                $instagramInfo = $flowService->getInstagramInfoForPage($selectedPageId);
                
                if ($instagramInfo) {
                    // Guardar informaci√≥n de Instagram
                    $conversationState->updateConversationData($chatId, 'instagram_info', $instagramInfo);
                    
                    // Enviar mensaje con informaci√≥n de Instagram
                    $instagramMessage = "üì∏ *Informaci√≥n de Instagram encontrada:*\n\n";
                    $instagramMessage .= "üë§ *Usuario:* @{$instagramInfo['username']}\n";
                    $instagramMessage .= "üìù *Nombre:* {$instagramInfo['name']}\n";
                    $instagramMessage .= "üë• *Seguidores:* " . number_format($instagramInfo['followers_count']) . "\n";
                    $instagramMessage .= "üìä *Seguidos:* " . number_format($instagramInfo['follows_count']) . "\n";
                    $instagramMessage .= "üì∏ *Publicaciones:* " . number_format($instagramInfo['media_count']) . "\n\n";
                    $instagramMessage .= "‚úÖ *Instagram conectado exitosamente!*\n\n";
                    
                    $this->sendMessage($chatId, $instagramMessage);
                } else {
                    // Enviar mensaje de que no hay Instagram
                    $this->sendMessage($chatId, "üì∏ *Instagram:* No conectado a esta fanpage.\n\n‚úÖ *Continuando con la configuraci√≥n...*");
                }
            }
            
            // Manejar flujo de plantilla
            if ($currentStep === 'template_choice' && $validation['data'] === 'plantilla') {
                // Saltar al paso de plantilla
                $conversationState->updateConversationStep($chatId, 'template_form');
                $templateMessage = $flowService->getStepMessage('template_form');
                return $this->sendMessage($chatId, $templateMessage);
            }
            
            // Manejar procesamiento de plantilla
            if ($currentStep === 'template_form') {
                // Procesar todos los datos de la plantilla
                $templateData = $validation['data'];
                
                // Mapear datos de la plantilla a formato del sistema
                $mappedData = $this->mapTemplateData($templateData, $state['data']);
                
                // Guardar todos los datos mapeados
                foreach ($mappedData as $key => $value) {
                    $conversationState->updateConversationData($chatId, $key, $value);
                }
                
                // Saltar directamente a la revisi√≥n
                $conversationState->updateConversationStep($chatId, 'review');
                $reviewMessage = $flowService->getStepMessage('review', $mappedData);
                return $this->sendMessage($chatId, $reviewMessage);
            }
            
            // Obtener siguiente paso
            $nextStep = $flowService->getNextStep($currentStep);
            
            Log::info('üîÑ Avanzando al siguiente paso', [
                'chat_id' => $chatId,
                'current_step' => $currentStep,
                'next_step' => $nextStep
            ]);
            
            if ($nextStep === 'complete') {
                // Crear campa√±a
                return $this->createCampaignFromConversation($chatId);
            }
            
            // Avanzar al siguiente paso
            $conversationState->updateConversationStep($chatId, $nextStep);
            $nextMessage = $flowService->getStepMessage($nextStep, $state['data']);
            
            Log::info('üì§ Enviando mensaje del siguiente paso', [
                'chat_id' => $chatId,
                'next_step' => $nextStep,
                'message_length' => strlen($nextMessage)
            ]);
            
            return $this->sendMessage($chatId, $nextMessage);
            
        } catch (\Exception $e) {
            Log::error('‚ùå Error en conversaci√≥n', [
                'error' => $e->getMessage(),
                'chat_id' => $chatId,
                'text' => $text
            ]);
            
            return $this->sendMessage($chatId, "‚ùå *Error procesando la conversaci√≥n.*\n\nUsa /cancelar para salir o /crear_campana para comenzar de nuevo.");
        }
    }
    
    private function cancelCommand($chatId, $message)
    {
        $conversationState = new ConversationStateService();
        $conversationState->clearConversationState($chatId);
        
        return $this->sendMessage($chatId, "‚ùå *Conversaci√≥n cancelada.*\n\nUsa /crear_campana para comenzar de nuevo.");
    }
    
    private function progressCommand($chatId, $message)
    {
        $conversationState = new ConversationStateService();
        
        if (!$conversationState->isConversationActive($chatId)) {
            return $this->sendMessage($chatId, "‚ÑπÔ∏è *No hay conversaci√≥n activa.*\n\nUsa /crear_campana para comenzar.");
        }
        
        $summary = $conversationState->getConversationSummary($chatId);
        return $this->sendMessage($chatId, $summary);
    }
    
    private function createCampaignFromConversation($chatId)
    {
        try {
            $conversationState = new ConversationStateService();
            $state = $conversationState->getConversationState($chatId);
            
            Log::info('üöÄ Creando campa√±a desde conversaci√≥n', [
                'chat_id' => $chatId,
                'data' => $state['data']
            ]);
            
            // Convertir datos de la conversaci√≥n al formato requerido por MetaCampaignCreatorService
            $campaignData = $this->convertConversationDataToCampaignData($state['data']);
            
            // Obtener cuenta de Facebook activa
            $facebookAccount = \App\Models\FacebookAccount::where('is_active', true)->first();
            
            if (!$facebookAccount) {
                return $this->sendMessage($chatId, "‚ùå *Error:* No hay cuenta de Facebook activa configurada.");
            }
            
            // Crear campa√±a usando el servicio
            $campaignCreator = new \App\Services\MetaCampaignCreatorService($facebookAccount);
            $result = $campaignCreator->createCampaign($campaignData);
            
            if ($result['success']) {
                $successMessage = "‚úÖ *¬°Campa√±a creada exitosamente!*\n\n";
                $successMessage .= "üìä *Detalles de la campa√±a:*\n";
                $successMessage .= "‚Ä¢ Campa√±a ID: `{$result['campaign']['id']}`\n";
                $successMessage .= "‚Ä¢ Conjunto de Anuncios ID: `{$result['adset']['id']}`\n";
                $successMessage .= "‚Ä¢ Anuncio ID: `{$result['ad']['id']}`\n";
                $successMessage .= "‚Ä¢ Nombre: {$campaignData['name']}\n";
                $successMessage .= "‚Ä¢ Objetivo: {$campaignData['objective']}\n";
                $successMessage .= "‚Ä¢ Presupuesto Diario: \${$campaignData['daily_budget']}\n";
                
                if (!empty($result['warnings'])) {
                    $successMessage .= "\n‚ö†Ô∏è *Advertencias:*\n";
                    foreach ($result['warnings'] as $warning) {
                        $successMessage .= "‚Ä¢ {$warning}\n";
                    }
                }
                
                if ($result['is_development_mode']) {
                    $successMessage .= "\nüí° *Nota:* App en modo desarrollo. El anuncio se cre√≥ como placeholder.";
                    $successMessage .= "\nüìù *Para crear anuncios reales, necesitas hacer la app p√∫blica.*";
                }
                
                $successMessage .= "\nüéâ *Tu campa√±a est√° siendo procesada y estar√° activa en unos minutos.*";
                
            } else {
                $errorMessage = "‚ùå *Error creando la campa√±a:*\n\n";
                if (isset($result['error'])) {
                    $errorMessage .= "‚Ä¢ {$result['error']}\n";
                }
                if (!empty($result['errors'])) {
                    foreach ($result['errors'] as $error) {
                        $errorMessage .= "‚Ä¢ {$error}\n";
                    }
                }
                $errorMessage .= "\nüí° *Usa /crear_campana para intentar nuevamente.*";
                
                return $this->sendMessage($chatId, $errorMessage);
            }
            
            // Limpiar estado de conversaci√≥n
            $conversationState->clearConversationState($chatId);
            
            return $this->sendMessage($chatId, $successMessage);
            
        } catch (\Exception $e) {
            Log::error('‚ùå Error creando campa√±a', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'chat_id' => $chatId
            ]);
            
            return $this->sendMessage($chatId, "‚ùå *Error creando la campa√±a.*\n\nUsa /crear_campana para intentar nuevamente.");
        }
    }

    /**
     * Convertir datos de la conversaci√≥n al formato requerido por MetaCampaignCreatorService
     */
    private function convertConversationDataToCampaignData(array $conversationData): array
    {
        // Obtener servicios necesarios
        $flowService = new \App\Services\CampaignCreationFlowService();
        $metaService = new \App\Services\MetaApiService();
        
        // Obtener cuenta de Facebook activa
        $facebookAccount = \App\Models\FacebookAccount::where('is_active', true)->first();
        
        // Obtener cuentas publicitarias y fanpages
        $adAccounts = $flowService->getAvailableFacebookAccounts();
        $fanpages = $flowService->getAvailableFanpages();
        
        // Mapear IDs a datos reales
        $selectedAdAccount = $adAccounts[$conversationData['ad_account'] - 1] ?? null;
        $selectedFanpage = $fanpages[$conversationData['fanpage'] - 1] ?? null;
        
        if (!$selectedAdAccount || !$selectedFanpage) {
            throw new \Exception('Cuenta publicitaria o fanpage no encontrada');
        }
        
        // Convertir objetivo de conversaci√≥n a objetivo de Meta
        $objectiveMapping = [
            'TRAFFIC' => 'OUTCOME_TRAFFIC',
            'CONVERSIONS' => 'OUTCOME_SALES',
            'MESSAGES' => 'OUTCOME_ENGAGEMENT',
            'REACH' => 'OUTCOME_AWARENESS'
        ];
        
        $objective = $objectiveMapping[$conversationData['campaign_objective']] ?? 'OUTCOME_TRAFFIC';
        
        // Parsear audiencia
        $audienceDetails = $conversationData['audience_details'] ?? '18-65 Ambos';
        preg_match('/(\d+)-(\d+)/', $audienceDetails, $ageMatches);
        $ageMin = $ageMatches[1] ?? 18;
        $ageMax = $ageMatches[2] ?? 65;
        
        $genders = [1, 2]; // Ambos g√©neros por defecto
        if (strpos($audienceDetails, 'Hombres') !== false) {
            $genders = [2];
        } elseif (strpos($audienceDetails, 'Mujeres') !== false) {
            $genders = [1];
        }
        
        return [
            'name' => $conversationData['campaign_name'],
            'objective' => $objective,
            'ad_account_id' => $selectedAdAccount['app_id'],
            'page_id' => $selectedFanpage['page_id'],
            'daily_budget' => (int) $conversationData['daily_budget'],
            'geolocation' => $conversationData['geolocation'],
            'age_min' => (int) $ageMin,
            'age_max' => (int) $ageMax,
            'genders' => $genders,
            'ad_copy' => $conversationData['ad_copy'],
            'ad_name' => $conversationData['ad_name'],
            'link' => 'https://example.com', // Por defecto, se puede personalizar
            'description' => $conversationData['ad_copy'],
            'special_ad_categories' => []
        ];
    }

    private function getHelpMessage()
    {
        return "ü§ñ *Bot de AdM√©tricas - Ayuda*\n\n" .
               "üìã *Comandos disponibles:*\n" .
               "/start - Iniciar el bot\n" .
               "/crear_campana - Crear nueva campa√±a (flujo completo)\n" .
               "/otro_ad - Crear otro anuncio (mantiene cuenta publicitaria)\n" .
               "/mis_cuentas - Ver cuentas disponibles\n" .
               "/planes - Ver planes publicitarios\n" .
               "/estado - Estado del sistema\n" .
               "/progreso - Ver progreso de conversaci√≥n activa\n" .
               "/cancelar - Cancelar conversaci√≥n activa\n" .
               "/help - Mostrar esta ayuda\n\n" .
               "üí° *Tips:*\n" .
               "‚Ä¢ Usa /crear_campana para comenzar el flujo completo\n" .
               "‚Ä¢ Usa /otro_ad para crear anuncios adicionales sin repetir configuraci√≥n";
    }
}